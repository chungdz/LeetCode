/*
下一个排列
实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须原地修改，只允许使用额外常数空间。

以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
*/
#include <vector>
using namespace std;

/*

1、从后向前扫，记录最大值

2、出现的第一个位置上的值小于最大值的话，就停止扫描，把当前位置往后大于当前值但是又最小的值和当前位置做替换

3、扫到头都没出现2情况，做一个位置对换，(N / 2) - 1位置前的数i和N-i替换

4、2情况完成后，需要让后续值最小，做一个快排
*/

class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        
    }
};